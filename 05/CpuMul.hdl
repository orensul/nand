/**
* This chip is an extension of the book CPU by using the extended ALU.
* More specificly if instruction[15]==0 or (instruction[14] and instruction[13] equals 1)
* the CpuMul behave exactly as the book CPU.
* While if it is C instruction and instruction[13] == 0 the output will be D*A/M 
* (according to instruction[12]).
* Moreover, if it is c instruction and instruction[14] == 0 it will behave as follows:
*
* instruction:  | 12 | 11 | 10 |
* _____________________________
* shift left D  | 0  | 1  | 1  |
* shift left A  | 0  | 1  | 0  |
* shift left M  | 1  | 1  | 0  |
* shift right D | 0  | 0  | 1  |
* shift right A | 0  | 0  | 0  |
* shift right M | 1  | 0  | 0  |
**/

CHIP CpuMul{

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset=1) or continue executing
                         // the current program (reset=0).

    OUT outM[16],        // M value output
        writeM,          // Write into M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

     PARTS:
	 
	// psuedo code:
	
	
	
	
	// if (instruction[15]==0 || (instruction[14]&&instruction[13])) do CPU 
    // if (instruction[15] && instruction[13]==0) 
	//		if(instruction[12]) do D*M
	//		else do D*A
	// if (instruction[15]&&instruction[14]==0)
	//		if (instruction[12]) do ExtendAlu D,M, instruvtion = instruction[15..7]
	//		else ExtenfAlu D,A, instruvtion = instruction[15..7]
   
	
        // Using of Destination Bits
        // If it's C instruction, ALU output simultnously fed into 3 registers: D-Register, 
        // A-Register, M-Register. this code decides by the 3 destination bits 
        // (exm. 000 no container will recive the output, 111 all of them will recive)

        And(a = instruction[15], b = instruction[3], out = writeM);
        And(a = instruction[15], b = instruction[4], out = IsALUOutToDReg);
        And(a = instruction[15], b = instruction[5], out = IsALUOutToAReg);

        // choose the input to Register A it can be the ALU output or the instruction
        // it will be ALU output if it's C instruction and the bit number 5 is 1.
        Mux16(a = instruction, b = ALUOut, sel = IsALUOutToAReg, out = ARegInput);

        // we have two options in which we should load new value into A Register
        // 1. It's A Instruction - we should load the instruction
        // 2. It's C Instruction and bit number 5 in the instruction is 1

        Not(in = instruction[15], out = IsAInstruction);
        Or(a = IsAInstruction, b = IsALUOutToAReg, out = ShouldLoadToAReg);

        // Load into ARegister the new input or stay with the same value in the register
        // According to ShouldLoadToAReg
        ARegister(in = ARegInput, load = ShouldLoadToAReg, out = ARegOut, 
        out[0..14] = addressM);

        // Now decides if to load into  DRegister
        DRegister(in = ALUOut, load = IsALUOutToDReg, out = DRegOut);    

 
        // determine what will be the input to the ALU
        // From D register or From A register / M register

        Mux16(a = ARegOut, b = inM, sel = instruction[12], out = AOrMRegister); 

        // Using Control Bits to know which operation ALU should do according to 
        // 6 bits (also taken from the instruction)

        // Call ALU for calculation
		ExtendAlu(x = DRegOut, y = AOrMRegister, instruction = instruction[6..14],
		out = outM, out = ALUOut, zr = IsZero, ng = IsNeg );

        // Program Counter (PC) logic:
        // if (reset==1) PC = 0
        // else load = f(jump bits, ALU control outputs)
        // if (load==1) PC = A
        // else PC++

        // data of ALU output
        Or(a = IsZero, b = IsNeg, out = IsNotPos);
        Not(in = IsNotPos, out = IsPos);

        // data from first 3 bits of the instruction (j bits)

        And(a = instruction[0], b = IsPos, out = JGT); // JGT
        And(a = instruction[1], b = IsZero, out = JEQ); // JEQ
        And(a = instruction[2], b = IsNeg, out = JLT); // JLT

        Or(a = JEQ, b = JLT, out = JLE);
        Or(a = JLE, b = JGT,out = Jump);

        And(a = Jump, b = instruction[15], out = ShouldLoadPC);
        PC(in = ARegOut, load = ShouldLoadPC, reset = reset, inc = true, 
            out[0..14] = pc);

}
    