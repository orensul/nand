import JackTokenizer
import JackAnalyzer

# global dictionary and lists
keywords_mapping = {'class': 'class', 'field': 'classVarDec', 'static': 'classVarDec',
                    'constructor': 'subroutineDec', 'function': 'subroutineDec',
                    'method': 'subroutineDec', 'var': 'varDec', 'let': 'letStatement',
                    'do': 'doStatement', 'if': 'ifStatement', 'while': 'whileStatement',
                    'return': 'returnStatement'}
statements = ['let', 'if', 'while', 'do', 'return']
op = ['+', '-', '*', '/', '&', '"', '|', '<', '>', '=']


# constants
TOKEN_NAME = 0
TOKEN_TYPE = 1


class CompilationEngine:
    """
    Effects the actual compilation output. Gets its input from a JackTokenizer and emits
    its parsed structure into an output file/stream.
    The output is generated by a series of compilexxx routines,
    one for every syntactic element xxx of the Jack grammar.
    """
    def __init__(self, folder_path, jack_file_name):
        """
        Constructor
        """
        self.tokenizer = JackTokenizer.JackTokenizer(folder_path, jack_file_name)

        self.xml_lines = []
        self.output_file_path = folder_path + jack_file_name.replace\
            (JackAnalyzer.SOURCE_FILE_EXTENSION, JackAnalyzer.DEST_FILE_EXTENSION)

        # compile class will drive the compile xxx methods
        self.compile_class()

        # prepare the file for writing
        self.xml_file = open(self.output_file_path, 'w')

        # write output xml file from our xml_lines list
        self.write_xml_file()

    def append_next_xml_line(self):
        """
        This method create xml entry from the next token by using tokenizer.advance()
        """
        value, element_name = self.tokenizer.advance()
        if value in op:
            value = self.change_symbol_for_xml_val(value)
        xml_row = self.create_xml_entry(element_name, value)
        self.xml_lines.append(xml_row)

    def append_xml_lines(self, num_of_lines):
        """
        Call to append_next_xml_line method which creates xml row, several times
        :param num_of_lines: number of lines to create
        """
        for i in range(num_of_lines):
            self.append_next_xml_line()

    def compile_class(self):
        """
        Compiles a complete class.
        """
        self.xml_lines.append("<class>")
        # keyword: class
        # identifier: name of class
        # symbol: {
        self.append_xml_lines(3)
        # compile the variable declarations part of the class if exist
        self.compile_var_dec(True)
        # class can contain constructor and one or more methods or functions (subroutines)
        # here we will compile all of the subroutines
        while self.tokenizer.peek_next_token()[TOKEN_NAME] in keywords_mapping.keys() \
                and keywords_mapping[self.tokenizer.peek_next_token()[TOKEN_NAME]] == \
                'subroutineDec':
            self.compile_subroutine()
        # symbol: }
        self.append_next_xml_line()
        self.xml_lines.append("</class>")

    def compile_var_dec(self, is_class_var_dec):
        """
        :param is_class_var_dec: boolean, true if we compile class var dec, otherwise,
        we compile var inside subroutine of the class
        """
        if is_class_var_dec:
            var_dec_str = 'classVarDec'
        else:
            var_dec_str = 'varDec'

        while self.tokenizer.peek_next_token()[TOKEN_NAME] in keywords_mapping.keys() \
                and keywords_mapping[self.tokenizer.peek_next_token()[TOKEN_NAME]] \
                == var_dec_str:
            self.xml_lines.append('<' + var_dec_str + '>')
            # keyword field or static
            # identifier variable type 
            # identifier: variable name
            self.append_xml_lines(3)
            # compile line of multi variable declarations (Separated by comma)
            while self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.COMMA:
                # symbol: ,
                # identifier: new var name
                self.append_xml_lines(2)
            # symbol: ;
            self.append_next_xml_line()
            self.xml_lines.append('</' + var_dec_str + '>')

    def compile_subroutine(self):
        """
        Compiles a complete method, function, or constructor.
        """
        self.xml_lines.append('<subroutineDec>')
        # keyword: type of the subroutine
        # identifier: return type of the subroutine
        # identifier: name of subroutine
        # symbol: (
        self.append_xml_lines(4)
        # compile the parameters of the subroutine
        self.compile_parameter_list()
        # symbol: )
        self.append_next_xml_line()
        self.xml_lines.append('<subroutineBody>')
        # symbol: {
        self.append_next_xml_line()
        # compile the variable declarations part of the subroutine if exist
        self.compile_var_dec(False)
        # compile the subroutine body
        self.compile_statements()
        # symbol: }
        self.append_next_xml_line()
        self.xml_lines.append('</subroutineBody>')
        self.xml_lines.append('</subroutineDec>')

    def compile_parameter_list(self):
        """
        Compiles parameter list
        """
        self.xml_lines.append('<parameterList>')
        while not self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                JackTokenizer.END_PARENTHESES:
            self.append_next_xml_line()
        self.xml_lines.append('</parameterList>')

    def compile_statements(self):
        """
        Compiles a sequence of statements
        """
        self.xml_lines.append('<statements>')
        # now, it can be one of the following:
        # letStatement or ifStatement or whileStatement or doStatement or returnStatement
        token_name = self.tokenizer.peek_next_token()[TOKEN_NAME]
        while token_name in statements:
            if token_name == 'let':
                self.compile_let()
            elif token_name == 'if':
                self.compile_if()
            elif token_name == 'while':
                self.compile_while()
            elif token_name == 'do':
                self.compile_do()
            elif token_name == 'return':
                self.compile_return()
            # next statement
            token_name = self.tokenizer.peek_next_token()[TOKEN_NAME]

        self.xml_lines.append('</statements>')

    def compile_do(self):
        """
        Compiles a do statement.
        """
        self.xml_lines.append('<doStatement>')
        # keyword: do
        # identifier: name of do
        self.append_xml_lines(2)
        if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.DOT:
            # symbol: . 
            # identifier: name of func
            self.append_xml_lines(2)

        # symbol: (
        self.append_next_xml_line()
        self.compile_expression_list()

        # symbol: )
        # symbol: ;
        self.append_xml_lines(2)
        self.xml_lines.append('</doStatement>')

    def compile_let(self):
        """
        Compiles a let statement.
        """
        self.xml_lines.append('<letStatement>')
        # keyword: let
        # identifier: name of assignee
        self.append_xml_lines(2)
        if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.START_BRACKETS:
            # symbol: [
            self.append_next_xml_line()
            self.compile_expression()
            # symbol: ]
            self.append_next_xml_line()
        # symbol: =
        self.append_next_xml_line()
        self.compile_expression()
        # symbol: ;
        self.append_next_xml_line()
        self.xml_lines.append('</letStatement>')

    def compile_while(self):
        """
        Compiles a while statement.
        """
        self.xml_lines.append('<whileStatement>')
        # keyword: while
        # symbol: (
        self.append_xml_lines(2)
        self.compile_expression()
        # symbol: )
        # symbol: {
        self.append_xml_lines(2)
        self.compile_statements()
        # symbol: }
        self.append_next_xml_line()
        self.xml_lines.append('</whileStatement>')

    def compile_return(self):
        """
        Compiles a return statement.
        """
        self.xml_lines.append('<returnStatement>')
        # keyword: return
        self.append_next_xml_line()

        # it can be return; or return with expression and then ;
        if not self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.SEMICOLON:
            self.compile_expression()

        # symbol: ;
        self.append_next_xml_line()

        self.xml_lines.append('</returnStatement>')

    def compile_if(self):
        """
        Compiles an if statement, possibly with a trailing else clause.
        """
        self.xml_lines.append('<ifStatement>')
        # keyword: if
        # symbol: (
        self.append_xml_lines(2)
        self.compile_expression()
        # symbol: )
        # symbol: {
        self.append_xml_lines(2)
        self.compile_statements()
        # symbol: }
        self.append_next_xml_line()

        if self.tokenizer.peek_next_token()[TOKEN_NAME] == 'else':
            # keyword: else
            # symbol: {
            self.append_xml_lines(2)
            self.compile_statements()
            # symbol: }
            self.append_next_xml_line()

        self.xml_lines.append('</ifStatement>')

    def compile_expression(self):
        """
        Compiles an expression.
        """
        self.xml_lines.append('<expression>')
        self.compile_term()

        while self.tokenizer.peek_next_token()[TOKEN_NAME] in op:
            # symbol: op
            self.append_next_xml_line()
            self.compile_term()
        self.xml_lines.append('</expression>')

    def compile_term(self):
        """
        Compiles a term. 
        """
        self.xml_lines.append('<term>')
        if self.tokenizer.peek_next_token()[TOKEN_NAME] in \
                JackTokenizer.keyword_constant or self.tokenizer.peek_next_token()\
            [TOKEN_TYPE] in ['integerConstant', 'stringConstant']:
            self.append_next_xml_line()
        elif self.tokenizer.peek_next_token()[TOKEN_TYPE] == 'identifier':
            # identifier: name of the identifier 
            self.append_next_xml_line()
            if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.DOT:
                # symbol: .
                # identifier: new
                # symbol: (
                self.append_xml_lines(3)
                self.compile_expression_list()
                # symbol: )
                self.append_next_xml_line()
            elif self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                    JackTokenizer.START_PARENTHESES:
                # symbol: (
                self.append_next_xml_line()
                self.compile_expression_list()
                # symbol: )
                self.append_next_xml_line()
            elif self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                    JackTokenizer.START_BRACKETS:
                # symbol: [
                self.append_next_xml_line()
                self.compile_expression()
                # symbol: ]
                self.append_next_xml_line()
        elif self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                JackTokenizer.START_PARENTHESES:
            # symbol: (
            self.append_next_xml_line()
            self.compile_expression()
            # symbol: )
            self.append_next_xml_line()
        elif self.tokenizer.peek_next_token()[TOKEN_NAME] in ['-', '~']:
            self.append_next_xml_line()
            self.compile_term()

        self.xml_lines.append('</term>')

    def compile_expression_list(self):
        """
        Compiles a (possibly empty) comma separated list of expressions.
        """
        self.xml_lines.append('<expressionList>')
        if not self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                JackTokenizer.END_PARENTHESES:
            self.compile_expression()
        while self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.COMMA:
            # symbol: ,
            self.append_next_xml_line()
            self.compile_expression()
        self.xml_lines.append('</expressionList>')

    def create_xml_entry(self, element_name, value):
        """
        This method is responsible to create xml line
        :param element_name: name of the element
        :param value: value of the element
        :return: line in the format of xml file which is generated from element_name
        and the value of the element
        """
        return "<" + element_name + "> " + value + " </" + element_name + ">"

    def change_symbol_for_xml_val(self, input_symbol_token):
        """
        This method is responsible to replace the tokens
        :param input_symbol_token: the input symbol token
        :return token after the replacement
        """
        if input_symbol_token == '<':
            replacement_val = '&lt;'
        elif input_symbol_token == '>':
            replacement_val = '&gt;'
        elif input_symbol_token == '"':
            replacement_val = '&quot;'
        elif input_symbol_token == '&':
            replacement_val = '&amp;'
        else:
            replacement_val = input_symbol_token
        return replacement_val

    def write_xml_file(self):
        """
        Writes the content of xml_lines list into the xml_file output file
        """
        for item in self.xml_lines:
            self.xml_file.write("{}\n".format(item))

    def print_xml_lines(self):
        """
        For the convenience of the programmer, prints the items in xml_lines list
        """
        for line in self.xml_lines:
            print(line)
