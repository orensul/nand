import JackTokenizer
import JackCompiler
import SymbolTable
import VMWriter

# constants
TOKEN_NAME = 0
TOKEN_TYPE = 1
MULTIPLY = 'Math.multiply'
DIV = 'Math.divide'
MEMORY_ALLOC = 'Memory.alloc'
STRING_NEW = 'String.new'
APPEND_CHAR = 'String.appendChar'
WHILE_START_LABEL = 'WHILE_EXP'
WHILE_END_LABEL = 'WHILE_END'
IF_TRUE = 'IF_TRUE'
IF_FALSE = 'IF_FALSE'
IF_END = 'IF_END'

# global dictionary and lists
keywords_mapping = {'class': 'class', 'field': 'classVarDec', 'static': 'classVarDec',
                    'constructor': 'subroutineDec', 'function': 'subroutineDec',
                    'method': 'subroutineDec', 'var': 'varDec', 'let': 'letStatement',
                    'do': 'doStatement', 'if': 'ifStatement', 'while': 'whileStatement',
                    'return': 'returnStatement'}
op_mapping = {'+': 'add', '-': 'sub', '>': 'gt', '<': 'lt', '&': 'and',
              '=': 'eq', '|': 'or', '~': 'not'}
statements = ['let', 'if', 'while', 'do', 'return']
op = ['+', '-', '*', '/', '&', '"', '|', '<', '>', '=']
# dictionary for replacing escape chars like \n \t \r \b with two chars \ and t, \ and n
# and so on
escape_chars = {'\t': '\\t', '\n': '\\n', '\r': '\\r', '\b': '\\b'}


class CompilationEngine:
    """
    Effects the actual compilation output. Gets its input from a JackTokenizer and emits
    its parsed structure into an output file/stream.
    The output is generated by a series of compilexxx() routines,
    one for every syntactic element xxx of the Jack grammar.
    """
    def __init__(self, folder_path, jack_file_name):
        """
        Constructor
        """
        # flag if to handle escape_chars or not
        self.handle_escape_chars = True

        self.tokenizer = JackTokenizer.JackTokenizer(folder_path, jack_file_name)
        self.symbol_table = SymbolTable.SymbolTable()

        self.while_counter = 0
        self.if_counter = 0

        self.jack_file_path = folder_path + jack_file_name
        self.output_file_path = folder_path + jack_file_name.replace\
            (JackCompiler.SOURCE_FILE_EXTENSION, JackCompiler.DEST_FILE_EXTENSION)

        self.vm_writer = VMWriter.VMWriter(self.output_file_path)
        self.vm_writer.set_file_name(jack_file_name)
        self.class_name = ""
        # compile class will drive the compile xxx methods
        self.compile_class()
        self.vm_writer.write_output_vm_file()

    def advance_tokens(self, num):
        for i in range(num):
            self.tokenizer.advance()

    def compile_class(self):
        """
        Compiles a complete class.
        """
        self.tokenizer.advance()  # class
        self.class_name = self.tokenizer.advance()[TOKEN_NAME]
        self.tokenizer.advance()  # {
        # compile the variables declaration part of the class if exist
        self.compile_var_dec(True)
        # class can contain constructor and one or more methods o functions (subroutines)
        # here we will compile all of the subroutines
        while self.tokenizer.peek_next_token()[TOKEN_NAME] in keywords_mapping.keys() \
                and keywords_mapping[self.tokenizer.peek_next_token()[TOKEN_NAME]] == \
                'subroutineDec':
            self.compile_subroutine_dec()
        self.tokenizer.advance()  # }

    def compile_var_dec(self, is_class_var_dec):
        """
        :param is_class_var_dec: boolean, true if we compile class var dec, otherwise,
        we compile var inside subroutine of the class
        """
        if is_class_var_dec:
            var_dec_str = 'classVarDec'
        else:
            var_dec_str = 'varDec'
        while self.tokenizer.peek_next_token()[TOKEN_NAME] in keywords_mapping.keys() \
                and keywords_mapping[self.tokenizer.peek_next_token()[TOKEN_NAME]] \
                == var_dec_str:
            var_kind = self.tokenizer.advance()[TOKEN_NAME]
            var_type = self.tokenizer.advance()[TOKEN_NAME]
            var_name = self.tokenizer.advance()[TOKEN_NAME]
            self.symbol_table.define(var_name, var_type, var_kind)
            # compile line of multi variable declarations (Separated by ',')
            while self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.COMMA:
                self.tokenizer.advance()  # ,
                var_name = self.tokenizer.advance()[TOKEN_NAME]
                self.symbol_table.define(var_name, var_type, var_kind)
            self.tokenizer.advance()  # ;

    def compile_subroutine_call(self, subroutine_name):
        """
        the caller must push arguments to stack and then call the subroutine
        If the subroutine is a method: the caller must first push a reference
        to the object on which the method is supposed to operate; next,
        the caller must push the args and then call the method.
        if the subroutine is a void: In jack does not return value,
        in vm must return a value, therefore the caller must pop the return value.
        """
        args_num = 0
        subroutine_type = self.symbol_table.property_of_named_identifier\
            (subroutine_name, SymbolTable.TYPE)

        if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.DOT:
            self.tokenizer.advance()  # .
            if subroutine_type is None:
                subroutine_type = subroutine_name
            else:
                args_num = 1
                self.write_push_var(subroutine_name)
            callee_name = self.tokenizer.advance()[TOKEN_NAME]
            subroutine_name = subroutine_type + '.' + callee_name
        else:
            args_num = 1
            self.vm_writer.write_push('pointer', '0')
            subroutine_name = self.class_name + '.' + subroutine_name

        self.tokenizer.advance()  # (
        # add number of arguments in parenthesis of subroutine call
        args_num += self.compile_expression_list()
        self.tokenizer.advance()  # )

        # call the subroutine
        self.vm_writer.write_call(subroutine_name, args_num)

    def compile_subroutine_dec(self):
        """
        Compiles a complete method, function, or constructor.
        """
        # start a fresh symbol table for subroutine
        self.symbol_table.start_subroutine()
        # reset counters of if and while
        self.if_counter = 0
        self.while_counter = 0

        subroutine_type = self.tokenizer.advance()[TOKEN_NAME]
        self.tokenizer.advance()  # return type of subroutine
        subroutine_name = self.tokenizer.advance()[TOKEN_NAME]
        self.tokenizer.advance()  # (

        # if it's a method, first we should define in the symbol table this argument
        # before we start to write the parameters into symbol table
        if subroutine_type == 'method':
            self.symbol_table.define('this', self.class_name, SymbolTable.ARG)

        # compile the parameters of the subroutine
        self.compile_parameter_list()

        self.advance_tokens(2)  # ){
        # compile the variable declarations part of the subroutine if exist
        self.compile_var_dec(False)
        # write the subroutine
        self.vm_writer.write_function(self.class_name + '.' + subroutine_name,
                                      self.symbol_table.var_count(SymbolTable.VAR))

        # compile the specific type of subroutine respectively
        if subroutine_type == 'constructor':
            self.compile_constructor()
        elif subroutine_type == 'method':
            self.compile_method()

        self.compile_statements()
        self.tokenizer.advance()  # }

    def compile_method(self):
        """
        compile_method - Sets THIS = argument 0
        """
        self.vm_writer.write_push('argument', 0)
        self.vm_writer.write_pop('pointer', 0)

    def compile_constructor(self):
        """
        compile_constructor - Push num of arguments of constructor, allocates space
        and anchor base address
        """
        # push constant num of class var
        self.vm_writer.write_push('constant', self.symbol_table.var_count(SymbolTable.FIELD))
        # allocate space for constructor in memory by OS method
        self.vm_writer.write_call(MEMORY_ALLOC, 1)
        # anchor this at the base address
        self.vm_writer.write_pop('pointer', 0)

    def compile_parameter_list(self):
        """
        Compiles a parameter list.
        """
        while not self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                JackTokenizer.END_PARENTHESES:
            argument_type = self.tokenizer.advance()[TOKEN_NAME]
            argument_name = self.tokenizer.advance()[TOKEN_NAME]
            # define the new argument in the symbol table
            self.symbol_table.define(argument_name, argument_type, SymbolTable.ARG)

            if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.COMMA:
                self.tokenizer.advance()  # ,

    def compile_statements(self):
        """
        Compiles a sequence of statements.
        """
        # now, it can be one of the following:
        # letStatement or ifStatement or whileStatement or doStatement or returnStatement
        token_name = self.tokenizer.peek_next_token()[TOKEN_NAME]
        while token_name in statements:
            if token_name == 'let':
                self.compile_let()
            elif token_name == 'if':
                self.compile_if()
            elif token_name == 'while':
                self.compile_while()
            elif token_name == 'do':
                self.compile_do()
            elif token_name == 'return':
                self.compile_return()
            # next statement
            token_name = self.tokenizer.peek_next_token()[TOKEN_NAME]

    def compile_do(self):
        """
        Compiles a do statement.
        """
        self.tokenizer.advance()  # do
        subroutine_name = self.tokenizer.advance()[TOKEN_NAME]
        self.compile_subroutine_call(subroutine_name)
        self.tokenizer.advance()  # ;
        # the caller of a void method must dump the returned value
        self.vm_writer.write_pop('temp', 0)

    def retrieve_kind_index_of_var(self, var_name):
        """
        :param var_name: name of variable
        :return: kind and index of the variable according to symbol table
        """
        kind = self.symbol_table.property_of_named_identifier(var_name,
                                                              SymbolTable.KIND)
        index = self.symbol_table.property_of_named_identifier(var_name,
                                                               SymbolTable.KIND_INDEX)
        return kind, index

    def write_push_var(self, var_name):
        """
        write VM that push the variable considering his kind (Field or something else)
        :param var_name: name of variable
        """
        kind, index = self.retrieve_kind_index_of_var(var_name)
        if kind == SymbolTable.FIELD:
            self.vm_writer.write_push('this', index)
        else:
            self.vm_writer.write_push(VMWriter.segments.get(kind), index)

    def write_pop_var(self, var_name):
        """
        write VM that pop the variable considering his kind (Field or something else)
        :param var_name: name of variable
        """
        kind, index = self.retrieve_kind_index_of_var(var_name)
        if kind == SymbolTable.FIELD:
            self.vm_writer.write_pop('this', index)
        else:
            self.vm_writer.write_pop(VMWriter.segments.get(kind), index)

    def compile_let(self):
        """
        Compiles a let statement.
        """
        array_access = False
        self.tokenizer.advance()  # keyword let
        name_of_assignee_var = self.tokenizer.advance()[TOKEN_NAME]

        # let with array access
        if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.START_BRACKETS:
            array_access = True
            # In case let a[i] = b[j] for example, in contrast to let a = b
            # here - without array access
            self.tokenizer.advance()  # [
            self.compile_expression()
            self.tokenizer.advance()  # ]
            self.write_push_var(name_of_assignee_var)
            self.vm_writer.write_arithmetic('add')

        # finish compilation of second expression
        self.tokenizer.advance()  # =
        self.compile_expression()
        self.tokenizer.advance()  # ;

        # if array_access sets that segment which represents the values
        # of current array, otherwise, pop to variable.
        if array_access:
            self.vm_writer.write_pop('temp', '0')
            self.vm_writer.write_pop('pointer', '1')
            self.vm_writer.write_push('temp', '0')
            self.vm_writer.write_pop('that', '0')
        else:
            self.write_pop_var(name_of_assignee_var)

    def compile_while(self):
        """
        Compiles a while statement.
        """

        self.advance_tokens(2)  # while (
        while_start_label, while_end_label = self.create_while_labels()
        self.while_counter += 1

        self.vm_writer.write_label(while_start_label)
        self.compile_expression()
        self.advance_tokens(2)  # ) {

        # computing ~(cond)
        self.vm_writer.write_arithmetic(op_mapping.get('~'))
        self.vm_writer.write_if(while_end_label)

        # execute statements
        self.compile_statements()
        self.tokenizer.advance()  # }

        self.vm_writer.write_go_to(while_start_label)
        self.vm_writer.write_label(while_end_label)

    def compile_return(self):
        """
        Compiles a return statement.
        """
        self.tokenizer.advance()  # return
        # it can be return; or return with expression and then ;
        if not self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.SEMICOLON:
            self.compile_expression()
        else:
            # we must return some value, so we will return 0;
            self.vm_writer.write_push('constant', 0)

        self.tokenizer.advance()  # ;
        self.vm_writer.write_return()

    def create_while_labels(self):
        """
        :return: names of current labels for while
        """
        curr_cnt = str(self.while_counter)
        return WHILE_START_LABEL + curr_cnt, WHILE_END_LABEL + curr_cnt

    def create_if_labels(self):
        """
        :return: names of current labels for if
        """
        curr_cnt = str(self.if_counter)
        return IF_END + curr_cnt, IF_TRUE + curr_cnt, IF_FALSE + curr_cnt

    def compile_if(self):
        """
        Compiles an if statement, possibly with a trailing else clause.
        """
        if_end, if_true, if_false = self.create_if_labels()
        self.if_counter += 1

        self.advance_tokens(2)  # if(
        self.compile_expression()
        self.tokenizer.advance()  # )

        self.vm_writer.write_if(if_true)
        self.vm_writer.write_go_to(if_false)
        self.vm_writer.write_label(if_true)

        self.tokenizer.advance()  # {
        self.compile_statements()
        self.tokenizer.advance()  # }

        if self.tokenizer.peek_next_token()[TOKEN_NAME] == 'else':
            self.vm_writer.write_go_to(if_end)
            self.vm_writer.write_label(if_false)
            self.advance_tokens(2)  # else {
            self.compile_statements()
            self.tokenizer.advance()  # }
            self.vm_writer.write_label(if_end)
        else:
            self.vm_writer.write_label(if_false)

    def compile_expression(self):
        """
        Compiles an expression.
        """
        self.compile_term()
        while self.tokenizer.peek_next_token()[TOKEN_NAME] in op:
            op_name = self.tokenizer.advance()[TOKEN_NAME]
            self.compile_term()
            if op_name == '/':
                self.vm_writer.write_call(DIV, '2')
            elif op_name == '*':
                self.vm_writer.write_call(MULTIPLY, '2')
            else:
                self.vm_writer.write_arithmetic(op_mapping[op_name])

    def compile_term(self):
        """
        Compiles a term.
        """
        # compile const
        if self.tokenizer.peek_next_token()[TOKEN_NAME] in JackTokenizer.keyword_constant:
            # According to compiling constants section in the book:
            # null and false are mapped to the constant 0
            # True is mapped to the constant -1 (push constant 0 and then neg)
            # pointer 0 - push base address of current object(this)
            token = self.tokenizer.advance()[TOKEN_NAME]
            if token == 'true':
                self.vm_writer.write_push('constant', '0')
                self.vm_writer.write_arithmetic('not')
            elif token in ['false', 'null']:
                self.vm_writer.write_push('constant', '0')
            # token = 'this'
            else:
                self.vm_writer.write_push('pointer', '0')
        elif self.tokenizer.peek_next_token()[TOKEN_TYPE] == 'integerConstant':
            token = self.tokenizer.advance()[TOKEN_NAME]
            self.vm_writer.write_push('constant', token)

        # String constants are created using the OS constructor String.new(length).
        # String assignments like x=cc...c are handled using a series of calls
        # to the OS routine String.appendChar(nextChar)

        elif self.tokenizer.peek_next_token()[TOKEN_TYPE] == 'stringConstant':
            token = self.tokenizer.advance()[TOKEN_NAME]
            if self.handle_escape_chars:
                # search in token which is a string const escape chars, and replace
                # according to the mapping in the dictionary escape_chars
                for escape_char in escape_chars:
                    token = token.replace(escape_char, escape_chars[escape_char])
            self.vm_writer.write_push('constant', len(token))
            self.vm_writer.write_call(STRING_NEW, '1')
            for char in token:
                self.vm_writer.write_push('constant', ord(char))
                self.vm_writer.write_call(APPEND_CHAR, '2')
        # compile - or ~ term
        elif self.tokenizer.peek_next_token()[TOKEN_NAME] in ['-', '~']:
            token = self.tokenizer.advance()[TOKEN_NAME]
            self.compile_term()
            if token == '~':
                self.vm_writer.write_arithmetic('not')
            elif token == '-':
                self.vm_writer.write_arithmetic('neg')
        # compile ( expression )
        elif self.tokenizer.peek_next_token()[TOKEN_NAME] == \
            JackTokenizer.START_PARENTHESES:
            self.tokenizer.advance()  # (
            self.compile_expression()
            self.tokenizer.advance()  # )
        # compile identifier
        elif self.tokenizer.peek_next_token()[TOKEN_TYPE] == 'identifier':
            name = self.tokenizer.advance()[TOKEN_NAME]
            if self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                    JackTokenizer.START_BRACKETS:
                self.tokenizer.advance()  # [
                self.compile_expression()
                self.tokenizer.advance()  # ]
                self.write_push_var(name)
                self.vm_writer.write_arithmetic('add')
                # pop that pointer
                self.vm_writer.write_pop('pointer', '1')
                # push that
                self.vm_writer.write_push('that', '0')
            elif self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.DOT \
                or self.tokenizer.peek_next_token()[TOKEN_NAME] == \
                            JackTokenizer.START_PARENTHESES:
                self.compile_subroutine_call(name)
            # push variable
            else:
                self.write_push_var(name)

    def compile_expression_list(self):
        """
        Compiles a (possibly empty) comma separated list of expressions.
        :return: Number of arguments in the expression
        """
        args_counter = 0

        # the only case we want to return args_counter = 0 is when we have token ')'
        # of type symbol, otherwise continue to compile the expression
        if self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.END_PARENTHESES\
            and self.tokenizer.peek_next_token()[TOKEN_TYPE] == 'symbol':
            return args_counter

        args_counter += 1
        self.compile_expression()

        # while there are more arguments to compile
        while self.tokenizer.peek_next_token()[TOKEN_NAME] == JackTokenizer.COMMA:
            self.tokenizer.advance()  # ,
            self.compile_expression()
            args_counter += 1

        return args_counter


